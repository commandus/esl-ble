# esl-ble: C++ библиотека с примером записи изображений в цифровые полочные ценники 
товаров (ESL) по BLE

## Пример утилиты esl-ble для загрузки изображения в один ценник

esl-ble загружает изображение из файла PNG в первый обнаруженный ценник, если ширина и высота
изображения совпадают с размером экрана ценника.

```shell
esl-ble <file.png>
```

Обязательный параметр - имя файла изображения. Черный и белый цвета передаются как есть,
без сглаживания. Если устройство поддерживает красный или желтый цвет, они передаются
в устройство, иначе пиксель желтого или красного цвета будет черным.

## Библиотека

В зависимости включите библиотеку

```
libesl-ble.lib
```

Подключите заголовочные файлы

```c++
#include "png2srgb8.h"
#include "ble-helper.h"
```

для импорта PNG изображений из массива или файла и отправки изображений в устройство.

Обычно процедура загрузки состоит из
- загрузки изображений в формат sRGB (4 байта на пиксель, первые три - RGB, четвертый байт -
яркость)
- обнаружения устройств в фоновом (асинхронном) режиме
- получения размера экранов обнаруженных ценников
- конвертации sRGB изображения с учетом имеющихся цветов у устройства и записи изображения в него
- отключения обнаружения устройств

### Загрузка файла PNG

```c++
    Png2sRgb png;
    int32_t sz = png.loadFile(fn);
    // png.srgb - loaded sRGB image
    std::cout << "width: " << png.w << " height: " << png.h << std::endl;
```

Если sz меньше 0, файл и изображение в нем повреждено и не загрузилось.

Член png.srgb содержит содержит изображение в виде массива sRGB пикселей в выделенной в куче памяти.

### Загрузка файлов изображений других форматов

Если нужно загружать файлы изображений в других форматах, нужно создать класс-наследник Image2sRgb

```c++
class Jpeg2sRgb : public Image2sRgb {
public:
    int32_t load(void *srcJpeg, size_t srcPngSize) override;
};
```

с перекрытым методом load(). Метод load() получает ссылку на загруженный в память файл и размер в байтах.

Метод load() должен выделить память в куче для члена класса srgb, записать туда прочитанное изображение 
в формате sRGB.

Метод load() возвращает размер изображения sRGB в байтах.

В случае неуспеха Метод load() возвращает отрицательное число - код ошибки.

### Обнаружение меток

Объект BLEHelper содержит методы для обнаружения меток и записи изображений.
Метод startDiscovery() запускает обнаружение BLE устройств, выполняемое асинхронно.

```c++
    BLEHelper b;
    b.startDiscovery();
```

Методы

- waitDiscover(число)
- waitDiscover(строка)

ожидают, когда будет обнаружено заданное количество устройств или устройство с заданным
MAC адресом в формате "ff:ff:92:13:76:14". Нужно указать все 6 байт MAC адреса. Последние 4 числа MAC адреса
написаны на ценнике, первые два числа всегда "ff:ff"

Оба метода возвращают количество обнаруженных устройств. 

Оба метода могут завершиться по тайм-ауту. Чтобы изменить время тайм-аута, принятое по умолчанию 
в 20 секунд, передайте вторым необязательным параметром значение тайм-аута в секундах.

В случае ошибки оба метода возвращают отрицательное число - код ошибки.

Метод stopDiscovery() останавливает асинхронное обнаружение меток.

```c++
    b.stopDiscovery(10);
```

Единственный необязательный параметр задает тайм-аут ожидания завершения выполнения метода в секундах.

### Просмотр меток

Член devices объекта BLEHelper содержит список обнаруженных меток

```c++
    for (auto &d : b.devices) {
        std::cout << macAddress2string(d.addr) << ' ' << d.metadata.toString() << ' ' << d.rssi 
        << "dBm. manufacturer specific data  " << d.metadata.val.toString() << "\n";
    }
```

### Типы меток

Класс ESLDeviceKnownType обращается к массиву eslDeviceKnownTypes1 с 22 известными
типами ценников.

Член metadata.val содержит массив байт специфичный для производителя, который устройство
передает при обнаружении устройства.

Первые два байта - просто магическое число, одинаковое для всех ценников.

Последний байт этого массива в пяти старших битах содержит тип устройства. 
Всего возможно 32 типа устройств. Известно пока 22 типа.

Третий байт документация описывает как поле флагов, в том числе можно определить тип устройства.

Третий и последний байты вдвоем задают тип устройства, но поскольку документация не содержит
информации об этом, нужно каждое устройство проверять.

### Метод обратного вызова при обнаружении метки

Если нужно обрабатывать обнаруженные ценники по мере их обнаружения, 
создайте класс-наследник OnDiscover с перекрытыми двумя методами

```c++
class ExampleDiscover : public OnDiscover {
public:
    void discoverFirstTime(DiscoveredDevice &device) override {
        std::cout << macAddress2string(device.addr) << ' ' << device.metadata.toString() << ' ' << device.rssi << "\n";
    }

    void discoverNextTime(DiscoveredDevice &device) override {
    }
};
```

Метод discoverFirstTime() вызывается при первом обнаружении метки, а метод discoverNextTime() 
при всех последующих.

При создании объекта BLEHelper передайте в конструктор экземпляр этого класса и указатель 
на загруженное изображение (либо другой объект, через который будет предоставлено изображение)   

```c++
    BLEHelper b(new ExampleDiscover(), &png);
```

## Сборка

Сборка делается CMake для Visual Studio. Можно использовать CLion с установленным 
на машине Visual Studio.  

## Ограничения

Сейчас есть только версия для Windows 11 (Windows 10) с WinRT.

WinRT требует компилятора с C++17 стандартом.

Имеющееся у меня устройство не поддерживает компрессию и двустороннее зеркало, поэтому
это не реализовано.

## Лицензия MIT

Смотрите лицензию в файле LICENSE.

## Тесты

Проверялась на метке - ценнике 250x128 BWR EPA.

## Как создать файл картинки ценника 

Можно использовать, например, программу magick:

```shell
magick -size 250x128 xc:red -draw "fill white rectangle 0,64 249,128 fill black rectangle 0,0 125,64 font Arial font-size 36 fill white text 134,44 '$42.99' text  8,44 'SALE!' fill black text 2,94 'Green bananas' font-size 14 text 4, 120 'Organic product. Best before 11/12/26'" example250x128.png
```

## Ссылки

- [Federico Poli. Gicisky Bluetooth ESL e-paper tag](https://github.com/fpoli/gicisky-tag)
- [zhihu.com. Протокол Bluetooth-тегов электронных этикеток полок Peake Smart](https://zhuanlan.zhihu.com/p/633113543)
- [Andrew  Graham. Picksmart/GiCiSky Electronic Shelf Label Image Uploader](https://shelflabels.andrewgraham.dev/)


## Лицензтя

MIT License (see LICENSE file). All rights reserved.

Copyright (C) 2026 Andrei Ivanov. All rights reserved.
